/**
 * Entity Configuration Service
 * 
 * Service layer for CRUD operations on entities and entity configurations.
 * All operations read from and write to mockData.ts.
 */

import type { 
  EntityType, 
  EntityConfig, 
  EntityRelation,
  EntityAction,
  BusinessLogicRule,
  PermissionConfig,
  User,
  Role
} from '../types/ontology';
import { 
  suppliersData, 
  materialsData, 
  productsData, 
  ordersData,
  materialStocksData,
  supplierEvaluationsData,
  supplier360ScorecardsData,
  mainMaterialSuppliersData,
  factoriesData,
  warehousesData,
  logisticsData,
  customersData
} from '../data/mockData';
import { entityConfigs, usersData, rolesData } from '../data/mockData';

// Entity CRUD operations

/**
 * Get all entities of a specific type
 */
export const getEntitiesByType = (type: EntityType): any[] => {
  const dataMap: Record<EntityType, any[]> = {
    supplier: suppliersData,
    material: materialsData,
    product: productsData,
    order: ordersData,
    factory: factoriesData,
    warehouse: warehousesData,
    logistics: logisticsData,
    customer: customersData,
  };
  // Return a copy of the array to prevent mutations
  const data = dataMap[type] || [];
  return [...data];
};

/**
 * Get entity by type and ID
 */
export const getEntityById = (type: EntityType, id: string): any | null => {
  const entities = getEntitiesByType(type);
  // Try different ID field names based on entity type
  return entities.find((e: any) => {
    if (e[`${type}Id`]) return e[`${type}Id`] === id;
    if (e.id) return e.id === id;
    if (e.materialCode && type === 'material') return e.materialCode === id;
    if (e.productId && type === 'product') return e.productId === id;
    if (e.orderId && type === 'order') return e.orderId === id;
    return false;
  }) || null;
};

/**
 * Create a new entity
 * Also creates corresponding entity configuration
 */
export const createEntity = (type: EntityType, data: Partial<any>): any => {
  const entities = getEntitiesByType(type);
  // Generate ID if not provided
  const id = data.id || data[`${type}Id`] || `${type.toUpperCase()}-${Date.now()}`;
  const newEntity = { ...data, id, [`${type}Id`]: id };
  entities.push(newEntity);
  
  // Bidirectional sync: create entity config
  const configKey = `${type}-${id}`;
  if (!entityConfigs.has(configKey)) {
    entityConfigs.set(configKey, {
      entityId: id,
      entityType: type,
      attributes: { ...data, id, [`${type}Id`]: id },
      relations: [],
      logicRules: [],
      actions: [],
      permissions: { roles: [], users: [] },
    });
  }
  
  return newEntity;
};

/**
 * Update an existing entity
 * Also syncs changes to entity configuration if exists
 */
export const updateEntity = (type: EntityType, id: string, data: Partial<any>): any => {
  const entity = getEntityById(type, id);
  if (!entity) {
    throw new Error(`Entity ${id} of type ${type} not found`);
  }
  Object.assign(entity, data);
  
  // Bidirectional sync: update entity config
  const configKey = `${type}-${id}`;
  const config = entityConfigs.get(configKey);
  if (config) {
    config.attributes = { ...config.attributes, ...data };
    entityConfigs.set(configKey, config);
  }
  
  return entity;
};

/**
 * Delete an entity
 * Also removes corresponding entity configuration
 */
export const deleteEntity = (type: EntityType, id: string): boolean => {
  const entities = getEntitiesByType(type);
  const index = entities.findIndex((e: any) => {
    if (e[`${type}Id`]) return e[`${type}Id`] === id;
    if (e.id) return e.id === id;
    if (e.materialCode && type === 'material') return e.materialCode === id;
    if (e.productId && type === 'product') return e.productId === id;
    if (e.orderId && type === 'order') return e.orderId === id;
    return false;
  });
  
  if (index === -1) {
    return false;
  }
  
  entities.splice(index, 1);
  
  // Bidirectional sync: delete entity config
  const configKey = `${type}-${id}`;
  entityConfigs.delete(configKey);
  
  return true;
};

/**
 * Get entity configuration by type and ID
 */
export const getEntityConfig = (entityType: EntityType, entityId: string): EntityConfig | null => {
  const key = `${entityType}-${entityId}`;
  return entityConfigs.get(key) || null;
};

// Knowledge Graph operations

/**
 * Get knowledge graph data for visualization
 * Returns nodes (entity types with counts) and edges (relationships)
 */
export const getKnowledgeGraphData = (): {
  nodes: Array<{ type: EntityType; count: number; name: string }>;
  edges: Array<{ source: EntityType; target: EntityType; relationType: string; count: number }>;
} => {
  const entityTypeNames: Record<EntityType, string> = {
    supplier: '‰æõÂ∫îÂïÜ',
    material: 'Áâ©Êñô',
    factory: 'Â∑•ÂéÇ',
    product: '‰∫ßÂìÅ',
    warehouse: '‰ªìÂ∫ì',
    order: 'ËÆ¢Âçï',
    logistics: 'Áâ©ÊµÅ',
    customer: 'ÂÆ¢Êà∑',
  };

  // Create nodes with counts
  const nodes = (['supplier', 'material', 'factory', 'product', 'warehouse', 'order', 'logistics', 'customer'] as EntityType[]).map(type => ({
    type,
    count: getEntitiesByType(type).length,
    name: entityTypeNames[type],
  }));

  // Build edges from entity configs relations
  const edgeMap = new Map<string, { source: EntityType; target: EntityType; relationType: string; count: number }>();
  
  entityConfigs.forEach((config) => {
    config.relations?.forEach((relation) => {
      const edgeKey = `${config.entityType}-${relation.targetType}`;
      const existing = edgeMap.get(edgeKey);
      if (existing) {
        existing.count += relation.count;
      } else {
        edgeMap.set(edgeKey, {
          source: config.entityType,
          target: relation.targetType as EntityType,
          relationType: relation.relationType,
          count: relation.count,
        });
      }
    });
  });

  const edges = Array.from(edgeMap.values());

  return { nodes, edges };
};

// AI Assistant operations

/**
 * Generate business rule from natural language input
 */
export const generateBusinessRule = (input: string, _entityType: EntityType): BusinessLogicRule | null => {
  const lowerInput = input.toLowerCase();
  
  // Pattern: Â∫ìÂ≠òÈ¢ÑË≠¶
  if ((lowerInput.includes('Â∫ìÂ≠ò') || lowerInput.includes('stock')) && 
      (lowerInput.includes('È¢ÑË≠¶') || lowerInput.includes('Ë≠¶Âëä') || lowerInput.includes('alert'))) {
    // Extract threshold if mentioned
    const thresholdMatch = input.match(/(\d+)/);
    const threshold = thresholdMatch ? thresholdMatch[1] : '100';
    return {
      ruleId: `rule-${Date.now()}`,
      ruleType: 'trigger' as const,
      name: 'Â∫ìÂ≠òÈ¢ÑË≠¶ËßÑÂàô',
      condition: `currentStock < ${threshold}`,
      action: 'sendAlert',
      level: 'critical' as const,
    };
  }
  
  // Pattern: Ë¥®ÈáèÊ£ÄÊü•
  if ((lowerInput.includes('Ë¥®Èáè') || lowerInput.includes('quality')) && 
      (lowerInput.includes('Ê£ÄÊü•') || lowerInput.includes('check'))) {
    return {
      ruleId: `rule-${Date.now()}`,
      ruleType: 'trigger' as const,
      name: 'Ë¥®ÈáèÊ£ÄÊü•ËßÑÂàô',
      condition: 'qualityRating < 80',
      action: 'qualityCheck',
      level: 'warning' as const,
    };
  }
  
  return null;
};

// User Management operations

/**
 * Get all users
 */
export const getUsers = (): User[] => {
  return Object.values(usersData);
};

/**
 * Get user by ID
 */
export const getUserById = (userId: number): User | null => {
  return usersData[userId] || null;
};

/**
 * Create a new user
 */
export const createUser = (data: Partial<User>): User => {
  const userId = Object.keys(usersData).length + 1;
  const newUser: User = {
    userId,
    name: `Áî®Êà∑${userId}`,
    email: data.email || `user${userId}@example.com`,
    role: data.role || 'viewer',
    phone: '',
    avatar: 'üë§',
    department: 'Êú™ÂàÜÈÖç',
    status: data.status || 'active',
  };
  usersData[userId] = newUser;
  return newUser;
};

/**
 * Update an existing user
 */
export const updateUser = (userId: number, data: Partial<User>): User => {
  const user = getUserById(userId);
  if (!user) {
    throw new Error(`User ${userId} not found`);
  }
  Object.assign(user, data);
  return user;
};

/**
 * Delete a user
 */
export const deleteUser = (userId: number): boolean => {
  const index = usersData.findIndex(u => u.userId === userId);
  if (index === -1) {
    return false;
  }
  usersData.splice(index, 1);
  return true;
};

// Role Management operations

/**
 * Get all roles
 */
export const getRoles = (): Role[] => {
  return Object.values(rolesData);
};

/**
 * Get role by ID
 */
export const getRoleById = (roleId: string): Role | null => {
  return rolesData[roleId] || null;
};

/**
 * Populate entity configurations from mock data
 * This function should be called after recreateAllMockDataRecords() to ensure
 * data consistency between frontend mockData and entityConfigs Map.
 */
export const populateEntityConfigs = (): void => {
  // Clear existing entityConfigs to avoid stale data
  entityConfigs.clear();

  console.log('=== Populating Entity Configurations ===');

  // Helper functions for default values
  const getDefaultAttributes = (_type: EntityType): Record<string, any> => {
    return {};
  };
  
  const getDefaultLogicRules = (type: EntityType): BusinessLogicRule[] => {
    const commonRules: BusinessLogicRule[] = [
      {
        ruleId: `rule-${type}-validation-001`,
        ruleType: 'validation',
        name: `${type}Êï∞ÊçÆÈ™åËØÅËßÑÂàô`,
        condition: `${type}Id !== null && ${type}Name !== ''`,
        level: 'warning',
      },
    ];
    
    switch (type) {
      case 'supplier':
        return [
          ...commonRules,
          {
            ruleId: 'rule-supplier-quality-001',
            ruleType: 'trigger',
            name: '‰æõÂ∫îÂïÜË¥®ÈáèÈ¢ÑË≠¶',
            condition: 'qualityRating < 80',
            action: 'sendAlert',
            level: 'warning',
          },
        ];
      case 'material':
        return [
          ...commonRules,
          {
            ruleId: 'rule-material-stock-001',
            ruleType: 'trigger',
            name: 'Áâ©ÊñôÂ∫ìÂ≠òÈ¢ÑË≠¶',
            condition: 'currentStock < safetyStock',
            action: 'sendAlert',
            level: 'critical',
          },
        ];
      case 'product':
        return [
          ...commonRules,
          {
            ruleId: 'rule-product-bom-001',
            ruleType: 'validation',
            name: 'BOMÂÆåÊï¥ÊÄßÊ£ÄÊü•',
            condition: 'BOM.length > 0',
            level: 'warning',
          },
        ];
      case 'order':
        return [
          ...commonRules,
          {
            ruleId: 'rule-order-delay-001',
            ruleType: 'trigger',
            name: 'ËÆ¢ÂçïÂª∂ÊúüÈ¢ÑË≠¶',
            condition: 'delay > 3',
            action: 'sendAlert',
            level: 'critical',
          },
        ];
      case 'warehouse':
        return [
          ...commonRules,
          {
            ruleId: 'rule-warehouse-capacity-001',
            ruleType: 'trigger',
            name: '‰ªìÂ∫ìÂÆπÈáèÈ¢ÑË≠¶',
            condition: 'utilizationRate > 90',
            action: 'sendAlert',
            level: 'warning',
          },
        ];
      case 'customer':
        return [
          ...commonRules,
          {
            ruleId: 'rule-customer-credit-001',
            ruleType: 'validation',
            name: 'ÂÆ¢Êà∑‰ø°Áî®ËØÑÁ∫ßÊ£ÄÊü•',
            condition: 'creditRating !== null',
            level: 'warning',
          },
        ];
      default:
        return commonRules;
    }
  };
  
  const getDefaultActions = (type: EntityType): EntityAction[] => {
    const commonActions: EntityAction[] = [
      {
        actionId: `action-${type}-view-001`,
        name: 'Êü•ÁúãËØ¶ÊÉÖ',
        description: `Êü•Áúã${type}ÁöÑËØ¶ÁªÜ‰ø°ÊÅØ`,
        icon: 'FileText',
        color: 'blue',
      },
      {
        actionId: `action-${type}-edit-001`,
        name: 'ÁºñËæë',
        description: `ÁºñËæë${type}‰ø°ÊÅØ`,
        icon: 'Edit',
        color: 'indigo',
      },
    ];
    
    switch (type) {
      case 'supplier':
        return [
          ...commonActions,
          {
            actionId: 'action-supplier-evaluate-001',
            name: 'ËØÑ‰º∞‰æõÂ∫îÂïÜ',
            description: 'ÂêØÂä®‰æõÂ∫îÂïÜËØÑ‰º∞ÊµÅÁ®ã',
            icon: 'Star',
            color: 'amber',
          },
        ];
      case 'material':
        return [
          ...commonActions,
          {
            actionId: 'action-material-purchase-001',
            name: 'ÂèëËµ∑ÈááË¥≠',
            description: '‰∏∫ËØ•Áâ©ÊñôÂèëËµ∑ÈááË¥≠ËÆ¢Âçï',
            icon: 'ShoppingCart',
            color: 'green',
          },
        ];
      case 'product':
        return [
          ...commonActions,
          {
            actionId: 'action-product-bom-001',
            name: 'ÁÆ°ÁêÜBOM',
            description: 'ÁºñËæë‰∫ßÂìÅBOMÁªìÊûÑ',
            icon: 'Layers',
            color: 'purple',
          },
        ];
      case 'order':
        return [
          ...commonActions,
          {
            actionId: 'action-order-track-001',
            name: 'Ë∑üË∏™ËÆ¢Âçï',
            description: 'Êü•ÁúãËÆ¢ÂçïÊâßË°åËøõÂ∫¶',
            icon: 'Truck',
            color: 'blue',
          },
        ];
      case 'warehouse':
        return [
          ...commonActions,
          {
            actionId: 'action-warehouse-inventory-001',
            name: 'Â∫ìÂ≠òÁõòÁÇπ',
            description: 'ÊâßË°å‰ªìÂ∫ìÂ∫ìÂ≠òÁõòÁÇπ',
            icon: 'Package',
            color: 'green',
          },
        ];
      case 'customer':
        return [
          ...commonActions,
          {
            actionId: 'action-customer-order-001',
            name: 'Êü•ÁúãËÆ¢ÂçïÂéÜÂè≤',
            description: 'Êü•ÁúãÂÆ¢Êà∑ÁöÑÊâÄÊúâËÆ¢Âçï',
            icon: 'ShoppingBag',
            color: 'blue',
          },
        ];
      default:
        return commonActions;
    }
  };
  
  const getDefaultPermissions = (_type: EntityType): PermissionConfig => {
    return { roles: [], users: [] };
  };
  
  // Populate Supplier configs
  console.log('Populating supplier configs...');
  const uniqueSupplierIds = Array.from(new Set(suppliersData.map(s => s.supplierId)));
  console.log('Unique supplier IDs:', uniqueSupplierIds.length);
  uniqueSupplierIds.forEach(supplierId => {
    const supplierEntries = suppliersData.filter(s => s.supplierId === supplierId);
    const firstEntry = supplierEntries[0];
    const key = `supplier-${supplierId}`;
    
    const evaluations = supplierEvaluationsData.filter(e => e.supplierId === supplierId);
    const avgQualityRating = evaluations.length > 0 
      ? Math.round(evaluations.reduce((sum, e) => sum + e.totalScore, 0) / evaluations.length)
      : 85;
    const riskLevel = evaluations.length > 0 && evaluations[0].riskLevel 
      ? evaluations[0].riskLevel 
      : 'low' as const;
    
    // Get supplier 360 scorecard for additional attributes
    const scorecard = supplier360ScorecardsData.find((sc: any) => sc.supplierId === supplierId);
    const materialCodes = supplierEntries.map(s => s.materialCode);
    const uniqueMaterialCodes = Array.from(new Set(materialCodes));
    
    // Calculate total annual purchase amount from mainMaterialSuppliersData
    const totalAnnualPurchase = mainMaterialSuppliersData
      .filter((m: any) => m.supplierId === supplierId)
      .reduce((sum: number, m: any) => sum + m.annualPurchaseAmount, 0);
    
    const attributes = {
      ...getDefaultAttributes('supplier'),
      supplierId: supplierId,
      supplierName: firstEntry.supplierName,
      supplyMaterials: uniqueMaterialCodes,
      supplyMaterialCount: uniqueMaterialCodes.length,
      qualityRating: avgQualityRating,
      riskLevel: riskLevel,
      contact: `ËÅîÁ≥ª‰∫∫-${supplierId}`,
      phone: `138-${supplierId.slice(-4)}-${Math.floor(Math.random() * 10000).toString().padStart(4, '0')}`,
      email: `supplier${supplierId.toLowerCase()}@example.com`,
      address: `‰æõÂ∫îÂïÜÂú∞ÂùÄ-${firstEntry.supplierName}`,
      establishedYear: 2015 + (supplierId.charCodeAt(supplierId.length - 1) % 10),
      registeredCapital: `${(500 + Math.floor(Math.random() * 2000))}‰∏áÂÖÉ`,
      certifications: ['ISO9001', 'ISO14001'],
      onTimeDeliveryRate: scorecard?.dimensions.onTimeDeliveryRate || 75,
      responseSpeed: scorecard?.dimensions.responseSpeed || 75,
      annualPurchaseAmount: totalAnnualPurchase > 0 ? `${(totalAnnualPurchase / 10000).toFixed(0)}‰∏áÂÖÉ` : '0‰∏áÂÖÉ',
    };
    
    const relations: EntityRelation[] = [
      {
        targetType: 'material',
        relationType: '‰∏ÄÂØπÂ§ö',
        count: uniqueMaterialCodes.length,
        sampleItems: uniqueMaterialCodes.slice(0, 3),
      },
    ];
    
    const config: EntityConfig = {
      entityId: supplierId,
      entityType: 'supplier',
      attributes,
      relations,
      logicRules: getDefaultLogicRules('supplier'),
      actions: getDefaultActions('supplier'),
      permissions: getDefaultPermissions('supplier'),
    };
    
    entityConfigs.set(key, config);
  });
  
  // Populate Material configs
  materialsData.forEach(material => {
    const key = `material-${material.materialCode}`;
    const supplierIds = Array.from(new Set(suppliersData
      .filter(s => s.materialCode === material.materialCode)
      .map(s => s.supplierId)));
    const allStockInfos = materialStocksData.filter(ms => ms.materialCode === material.materialCode);
    const totalStock = allStockInfos.reduce((sum, stock) => sum + stock.remainingStock, 0);
    const totalPurchaseQuantity = allStockInfos.reduce((sum, stock) => sum + stock.purchaseQuantity, 0);
    
    // Get main supplier info from mainMaterialSuppliersData
    const mainSupplier = mainMaterialSuppliersData.find((m: any) => m.materialCode === material.materialCode);
    
    // Determine unit based on material type
    const getUnit = (materialName: string): string => {
      if (materialName.includes('Èí¢Êùê') || materialName.includes('ÈìùÊùê') || materialName.includes('ÈìúÊùê')) return 'Âê®';
      if (materialName.includes('Â°ëÊñô') || materialName.includes('Ê©°ËÉ∂')) return 'ÂçÉÂÖã';
      return '‰ª∂';
    };
    
    const unit = getUnit(material.materialName);
    const unitPrice = material.materialCode === 'MAT-001' ? '5000' : material.materialCode === 'MAT-002' ? '8000' : '3000';
    
    const attributes = {
      ...getDefaultAttributes('material'),
      materialCode: material.materialCode,
      materialName: material.materialName,
      applicableProducts: material.applicableProductIds || [],
      applicableProductCount: material.applicableProductIds?.length || 0,
      currentStock: totalStock,
      currentStockWithUnit: `${totalStock} ${unit}`,
      safetyStock: Math.floor(totalStock * 0.3),
      safetyStockWithUnit: `${Math.floor(totalStock * 0.3)} ${unit}`,
      totalPurchaseQuantity: totalPurchaseQuantity,
      totalPurchaseQuantityWithUnit: `${totalPurchaseQuantity} ${unit}`,
      unit: unit,
      unitPrice: `${unitPrice}ÂÖÉ/${unit}`,
      minOrderQuantity: 100,
      minOrderQuantityWithUnit: `100 ${unit}`,
      shelfLife: '12‰∏™Êúà',
      specifications: 'Ê†áÂáÜËßÑÊ†º',
      mainSupplier: mainSupplier?.supplierName || supplierIds[0] || '',
      mainSupplierId: mainSupplier?.supplierId || supplierIds[0] || '',
      supplierCount: supplierIds.length,
      riskCoefficient: mainSupplier?.riskCoefficient || 20,
    };
    
    const relations: EntityRelation[] = [
      {
        targetType: 'product',
        relationType: 'Â§öÂØπÂ§ö',
        count: material.applicableProductIds?.length || 0,
        sampleItems: (material.applicableProductIds || []).slice(0, 3),
      },
      {
        targetType: 'supplier',
        relationType: 'Â§öÂØπÂ§ö',
        count: supplierIds.length,
        sampleItems: supplierIds.slice(0, 3),
      },
    ];
    
    const config: EntityConfig = {
      entityId: material.materialCode,
      entityType: 'material',
      attributes,
      relations,
      logicRules: getDefaultLogicRules('material'),
      actions: getDefaultActions('material'),
      permissions: getDefaultPermissions('material'),
    };
    
    entityConfigs.set(key, config);
  });
  
  // Populate Product configs
  productsData.forEach(product => {
    const key = `product-${product.productId}`;
    const orderIds = ordersData
      .filter(o => o.productId === product.productId)
      .map(o => o.orderId);
    const totalOrderQuantity = ordersData
      .filter(o => o.productId === product.productId)
      .reduce((sum, o) => sum + o.quantity, 0);
    
    const attributes = {
      ...getDefaultAttributes('product'),
      productId: product.productId,
      productName: product.productName,
      BOM: product.materialCodes || [],
      BOMCount: product.materialCodes?.length || 0,
      series: product.productId.startsWith('PROD-T') ? 'TÁ≥ªÂàó' : product.productId.startsWith('PROD-M') ? 'MÁ≥ªÂàó' : 'Ê†áÂáÜÁ≥ªÂàó',
      lifecycle: product.productId.includes('T20') ? 'Ë°∞ÈÄÄÊúü' : product.productId.includes('T40') || product.productId.includes('M3E') ? 'ÊàêÁÜüÊúü' : 'ÊàêÈïøÊúü',
      price: product.productId.includes('T20') ? '120000' : product.productId.includes('T40') ? '80000' : product.productId.includes('M3E') ? '18000' : '50000',
      cost: product.productId.includes('T20') ? '80000' : product.productId.includes('T40') ? '55000' : product.productId.includes('M3E') ? '12000' : '35000',
      warranty: '12‰∏™Êúà',
      weight: product.productId.includes('T20') ? '25kg' : product.productId.includes('T40') ? '20kg' : product.productId.includes('M3E') ? '900g' : '10kg',
      totalOrderCount: orderIds.length,
      totalOrderQuantity: totalOrderQuantity,
      status: totalOrderQuantity > 0 ? 'Âú®‰∫ß' : 'ÂÅú‰∫ß',
    };
    
    const relations: EntityRelation[] = [
      {
        targetType: 'material',
        relationType: 'Â§öÂØπÂ§ö',
        count: product.materialCodes?.length || 0,
        sampleItems: (product.materialCodes || []).slice(0, 3),
      },
      {
        targetType: 'order',
        relationType: '‰∏ÄÂØπÂ§ö',
        count: orderIds.length,
        sampleItems: orderIds.slice(0, 3),
      },
    ];
    
    const config: EntityConfig = {
      entityId: product.productId,
      entityType: 'product',
      attributes,
      relations,
      logicRules: getDefaultLogicRules('product'),
      actions: getDefaultActions('product'),
      permissions: getDefaultPermissions('product'),
    };
    
    entityConfigs.set(key, config);
  });
  
  // Populate Order configs
  ordersData.forEach(order => {
    const key = `order-${order.orderId}`;
    const product = productsData.find(p => p.productId === order.productId);
    const customer = customersData.find(c => c.customerName === order.client);
    
    // Calculate delay days
    const dueDate = new Date(order.dueDate);
    const today = new Date();
    const delayDays = Math.max(0, Math.floor((today.getTime() - dueDate.getTime()) / (1000 * 60 * 60 * 24)));
    
    // Calculate order amount (mock)
    const orderAmount = order.quantity * 5; // Mock calculation: 5‰∏á per unit
    
    // Determine stage based on status
    const stage = order.status === 'ÈááË¥≠‰∏≠' ? 'procurement' : order.status === 'Áîü‰∫ß‰∏≠' ? 'production' : order.status === 'ËøêËæì‰∏≠' ? 'shipping' : 'completed';
    
    // Determine customer level
    const customerLevel = customer?.creditRating === 'AAA' ? 'VIP' : customer?.creditRating === 'AA' ? 'A' : 'B';
    
    const attributes = {
      ...getDefaultAttributes('order'),
      orderId: order.orderId,
      orderName: order.orderName,
      client: order.client,
      productId: order.productId,
      productName: product?.productName || order.productId,
      quantity: order.quantity,
      orderDate: order.orderDate,
      dueDate: order.dueDate,
      status: order.status,
      amount: `¬•${orderAmount}w`,
      delay: delayDays,
      stage: stage,
      customer_level: customerLevel,
      priority: delayDays > 5 ? 'critical' : delayDays > 2 ? 'high' : 'medium',
    };
    
    const relations: EntityRelation[] = [
      {
        targetType: 'product',
        relationType: 'Â§öÂØπ‰∏Ä',
        count: 1,
        sampleItems: [order.productId],
      },
      {
        targetType: 'customer',
        relationType: 'Â§öÂØπ‰∏Ä',
        count: 1,
        sampleItems: customer ? [customer.customerId] : [order.client],
      },
    ];
    
    const config: EntityConfig = {
      entityId: order.orderId,
      entityType: 'order',
      attributes,
      relations,
      logicRules: getDefaultLogicRules('order'),
      actions: getDefaultActions('order'),
      permissions: getDefaultPermissions('order'),
    };
    
    entityConfigs.set(key, config);
  });
  
  // Populate Factory configs
  factoriesData.forEach(factory => {
    const key = `factory-${factory.factoryCode}`;
    const attributes = {
      ...getDefaultAttributes('factory'),
      ...factory,
    };
    const relations: EntityRelation[] = [
      {
        targetType: 'product',
        relationType: '‰∏ÄÂØπÂ§ö',
        count: factory.productList?.length || 0,
        sampleItems: (factory.productList || []).slice(0, 3),
      },
    ];
    const config: EntityConfig = {
      entityId: factory.factoryCode,
      entityType: 'factory',
      attributes,
      relations,
      logicRules: getDefaultLogicRules('factory'),
      actions: getDefaultActions('factory'),
      permissions: getDefaultPermissions('factory'),
    };
    entityConfigs.set(key, config);
  });
  
  // Populate Warehouse configs
  warehousesData.forEach(warehouse => {
    const key = `warehouse-${warehouse.warehouseCode}`;
    const associatedFactory = factoriesData.find(f => f.factoryCode === warehouse.associatedFactory);
    const utilizationRate = warehouse.capacity > 0 ? Math.round((warehouse.currentStock / warehouse.capacity) * 100) : 0;
    
    const attributes = {
      ...getDefaultAttributes('warehouse'),
      warehouseCode: warehouse.warehouseCode,
      warehouseName: warehouse.warehouseName,
      location: warehouse.location,
      capacity: warehouse.capacity,
      currentStock: warehouse.currentStock,
      utilizationRate: `${utilizationRate}%`,
      associatedFactory: warehouse.associatedFactory,
      associatedFactoryName: associatedFactory?.factoryName || warehouse.associatedFactory,
      storageType: warehouse.storageType,
      temperatureControl: warehouse.temperatureControl,
      availableCapacity: warehouse.capacity - warehouse.currentStock,
    };
    
    const relations: EntityRelation[] = [
      {
        targetType: 'factory',
        relationType: 'Â§öÂØπ‰∏Ä',
        count: 1,
        sampleItems: [warehouse.associatedFactory || 'FAC-001'],
      },
    ];
    
    const config: EntityConfig = {
      entityId: warehouse.warehouseCode,
      entityType: 'warehouse',
      attributes,
      relations,
      logicRules: getDefaultLogicRules('warehouse'),
      actions: getDefaultActions('warehouse'),
      permissions: getDefaultPermissions('warehouse'),
    };
    
    entityConfigs.set(key, config);
  });
  
  // Populate Logistics configs
  logisticsData.forEach((logistics, index) => {
    const key = `logistics-${logistics.logisticsId}`;
    const attributes = {
      ...getDefaultAttributes('logistics'),
      ...logistics,
    };
    const orderIds = ordersData
      .filter((_, idx) => idx % logisticsData.length === index)
      .map(o => o.orderId);
    const relations: EntityRelation[] = [
      {
        targetType: 'order',
        relationType: '‰∏ÄÂØπÂ§ö',
        count: orderIds.length,
        sampleItems: orderIds.slice(0, 3),
      },
    ];
    const config: EntityConfig = {
      entityId: logistics.logisticsId,
      entityType: 'logistics',
      attributes,
      relations,
      logicRules: getDefaultLogicRules('logistics'),
      actions: getDefaultActions('logistics'),
      permissions: getDefaultPermissions('logistics'),
    };
    entityConfigs.set(key, config);
  });
  
  // Populate Customer configs
  console.log('Populating customer configs...');
  console.log('Customers data length:', customersData.length);
  customersData.forEach(customer => {
    const key = `customer-${customer.customerId}`;
    const customerOrders = ordersData.filter(o => o.client === customer.customerName);
    
    const attributes = {
      ...getDefaultAttributes('customer'),
      customerId: customer.customerId,
      customerName: customer.customerName,
      contact: customer.contact || `ËÅîÁ≥ª‰∫∫-${customer.customerId}`,
      phone: customer.phone || `138-0000-${customer.customerId.slice(-4)}`,
      email: customer.email || `customer${customer.customerId.toLowerCase()}@example.com`,
      address: customer.address || `Âú∞ÂùÄ-${customer.customerName}`,
      serviceRegion: customer.serviceRegion || ['Âçé‰∏ú'],
      creditRating: customer.creditRating || 'BBB',
      orderHistory: customer.orderHistory || customerOrders.map(o => o.orderId),
      totalOrderCount: customerOrders.length,
      totalOrderAmount: customerOrders.reduce((sum, o) => sum + o.quantity * 5, 0), // Mock calculation
    };
    
    const relations: EntityRelation[] = [
      {
        targetType: 'order',
        relationType: '‰∏ÄÂØπÂ§ö',
        count: customerOrders.length,
        sampleItems: customerOrders.map(o => o.orderId).slice(0, 3),
      },
    ];
    
    const config: EntityConfig = {
      entityId: customer.customerId,
      entityType: 'customer',
      attributes,
      relations,
      logicRules: getDefaultLogicRules('customer'),
      actions: getDefaultActions('customer'),
      permissions: getDefaultPermissions('customer'),
    };
    
    entityConfigs.set(key, config);
  });

  console.log('Entity configurations populated. Total configs:', entityConfigs.size);
  console.log('=== Entity Config Population Complete ===');
};
